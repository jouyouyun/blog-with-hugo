+++
title = "python3 学习笔记"
date = 2018-12-02T21:38:21+08:00
lastmod = 2019-02-12T14:35:53+08:00
tags = ["python"]
categories = ["NOTE"]
draft = false
+++

## Python3 Study Notes {#python3-study-notes}

本人很少写 `python` 代码, 一般都是用 `go` 的, 去年时用 `python` 写过一些收集系统信息的工具, 当时是边看手册边写的. 如今又要用 `python` 来写一个生成 `xlsx` 的工具, 就又需要查看手册了, 至于为什么不用 `go` 写? 那是因为 `go` 的库不兼容永中. 在这里不得不说, 虽然 `go` 很火, 但是一些库还是不如 `python` 多, 不如 `python` 兼容性好.

为了避免以后再出这种事情, 这次就好好的了解下 `python`, 将它的用法按照自己对语言的理解分块记录下来. 要使用某种语言, 个人认为需要了解这些方面:

-   编码风格
-   变量的类型, 声明及使用方式
-   输入/输出
-   控制语句的写法
-   错误处理的用法
-   函数的用法, 还有语言支持的一些特性, `python` 中就有装饰器, `lambda` 语句等
-   对于面向对象语言还需要了解类的声明, 继承, 多态等的用法

还有一些就是此语言的一些特性, `python` 就还需要了解以下特性:

<!--more-->

-   模块的使用

下文就将按照这些内容来一一记录.

---


### 编码风格 {#编码风格}

-   变量名, 方法名和模块名建议小写, 单词以 `_` 分割, 类名建议驼峰命名风格, 首字母大写, 私有类可用一个 `_` 开头.
-   每行结尾尽量不要添加 `;`, 多行代码也不要写在一行
-   `python` 是以缩进来控制代码段的, 所以缩减建议使用 4 个空格
-   编码尽量使用 `utf-8`, `python` 默认使用 `ASCII`, 所以要在文件的开头添加 `# -*- coding: UTF-8 -*-` 或者 `#coding=utf-8` 来指定
-   `python` 有独一无二的注释方式: 文档字符串, 所以注释尽量用文档字符串(`"""xxxx"""`)
-   如果一个类不从其他类继承, 就显示的从 `object` 类继承
-   使用 `with` 语句来管理文件, 如 `open` 或 `close`
-   添加 `TODO` 时, 尽量在其后紧跟 `()`, 在里面写明作者名或 `email` 等其他标识信息, 然后紧跟一个 `:` 后面接着写要做的事情
-   每个导入模块都占一行, 不要一行导入多个模块
-   尽量定义一个 `main` 函数, 将主程序放入其中, 并在 "if <span class="underline"><span class="underline">name</span></span> `= '__main__':" 成立时执行 =main`, 这样被当作模块导入时就不会执行主程序


### 变量 {#变量}

`Python` 是动态语言, 变量的类型不固定, 根据值的类型而决定, 所以不用显示的声明变量， 用的时候直接赋值即可，如下:

```python
a = 1; // 此时是整型
print(a);
a = 'hello'; // 此时又为字符串类型
```

通常变量名全部大写的为 **常量**, **空值** 用 `None` 表示.

以 `_xxx` 或 `__xxx` 命名的函数或变量是私有变量, 不能被其他模块直接引用


#### 基础类型 {#基础类型}

这里将整型, 浮点型, 布尔和字符串看作是基本类型, 整型和浮点型的使用就不再介绍了, 布尔的值只能为 `True/False`, 而字符串的常见操作如下:

-   使用 `"""` 或 `'''` 可以嵌入长字符串
-   字符串可以通过下标来索引, `len` 函数获取长度
-   使用 `+` 进行拼接操作
-   字符串对象还内置了很多方法提供了一些常见功能, 具体请查阅手册

另外它们之间的相互转换是通过 `int(arg), float(arg), str(arg)` 这些内置的方法来处理的.


#### 列表 {#列表}

列表中可以包含不同类型的数据, 如:

```python
list = ["eggs", 1, 67.12];
```

通过 `list(seq)` 可以将一个序列转换为列表.

**array** 模块提供了固定类型的数据, 可以指定要转换的类型, 具体请查阅手册.

列表通过下标索引, `len` 函数获取大小.

列表对象常用的方法如下:

-   **append(item):** 附加元素
-   **insert(idx, item):** 插入元素
-   **pop(idx):** 删除指定位置的元素, 参数为空则删除最后一个元素

列表遍历:

```python
for <variable> in <array>:
    // do

// 带下标
for idx, name in enumerate(<array>):
    // do

// 列表中多个元素
for x, y in [(1, 1), (2, 4), (3, 9)]:
    // do

// 用 zip 同时遍历多个数组
a = [1, 2];
b = [5, 6];
for av, bv in zip(a, b):
    // do av=1, bv=5

// 生成
[x * x for x in range(1, 11) if x % 2 == 0]
```


#### 元组 {#元组}

元组(tuple) 是一个不可修改的列表, 元组中每个元素的指向是不可更改的, 但指向里的内容是可以更改的, 如元组中包含一个数组:

```python
t = ('1', 1, ["A", "B"]);
t[2][0] = "X";
t[2][1] = "Y";
```

---


#### 字典 {#字典}

语法:

```python
dict = {'<key>':<value>}
```

常用的对象方法:

-   **get(key, value):** 获取指定 `key` 的值, 如果不存在则返回 `value`, 如果 `value` 未指定则返回 `None`
-   **pop(key):** 删除指定的 `key`

使用字典需要注意以下几点:

-   字典中的 `key` 不能重复
-   字典中的 `key` 不可变, 所以只能用数字, 字符串和元组
-   字典的值则没有限制, 可以是任意对象

---


#### 集合 {#集合}

集合与字典类似, 是一组 `key` 的集合, 但不存储 `value`, 没有重复的 `key`.

要创建一个集合, 需要传入一个数组, 重复的元素会被自动过滤.

遍历:

```python
for <key> in <dict>:
    // do

// 带下标
for idx, name in dict.items():
    // do
```

```python
s = set([1, 2, 3 ,3]); // s: {1,2,3}
```

常用的对象方法:

-   **add(key):** 添加 `key`
-   **remove(key):** 删除 `key`

---


#### global 关键字 {#global-关键字}

`global` 关键字用于声明变量的作用域, 用法如下:

```python
# 全局变量
a = 1

def test():
    # 若下面这行注释掉, 则下面的 a 是局部变量, 'Global' 处的输出还是全局变量 1
    # 若下面这行取消注释, 则下面的 a 是全局变量, 'Gloabl' 出的输出是 5
    # global a
    a = 5
    print("In test:", a)

# Global
print("Global:", a)
```

输出, `global a` 注释掉时:

```python
In test: 5
Global: 1
```

输出, `global a` 取消注释时:

```python
In test: 5
Global: 5
```

---


#### 更多 {#更多}

上面的只是基础，想要更好的使用变量，还需要了解以下内容：

-   类型对象的方法

    `python` 中每种类型都是对象, 都提供了一些内置方法, 如字符串类型的 `replace()` 等

-   变量的内存分配

    变量只是值的引用, 具体的内存分配是在值的这一边, 有些类型的值是不可变的, 这些是需要深入了解的

-   结构体

    `python` 中没有结构体, 可以使用下列方式实现:

    -   使用 `struct` 模块来实现, 需要了解与 `c` 中类型的格式对照, 创建时需要指定结构体的成员类型
    -   使用类来实现, 在类的构造函数 `__init__` 中定义结构体成员

---


### 输入/输出 {#输入-输出}


#### 输入 {#输入}

使用 `raw_input(prompt)` 可以接受控制台的输入


#### 输出 {#输出}

使用 `print()` 可以打印内容到控制台, 格式化输出:

```python
n = 1;
s = "Joy";
print("The %d student's name is %s" % (n, s));
```

也可以使用 `format` 来格式化, 它会用传入的参数依次替换字符串内的占位符 {0}、{1}…… :

```python
// {3:.1f} 表示保留一位小数
s = "The {0} student's name is {1}, score: {3:.1f}".format(1, "Joy", 87.75);
print(s);
```

---


### 控制语句 {#控制语句}

控制语句中可以使用 `break, continue, pass` 关键字, `break` 与 `continue` 的作用与其他语言中的一样, `pass` 则是一个空语句, 不做任何事情, 一般是为了保持结构的完整性, 常被用来占位, 表明之后会实现.

**注意:** `python` 中没有 `goto` 和 `switch`.


#### IF {#if}

语法:

```python
if <condition>:
elif <condition>:
else:
```


#### FOR {#for}

```python
for <variable> in <array>:
    // do
else:
```

`else` 可选


#### WHILE {#while}

```python
while <condition>:
    // do
else:
```

`else` 可选

---


### 错误处理 {#错误处理}

语法:

```python
try:
    // do
except <error type> as e:
   // do
except <error type> as e:
else:
   // no error
finally:
   // do
```

如果 `finally` 存在, 则无论有没有异常都会执行, `else` 则在 `except` 都没进入时才执行.

---


### 函数 {#函数}

语法:

```python
def func(arg1, arg2=value, arg3=value):
    // do
    return ret1, ret2

# 不定长参数
def func(arg1, *vartuple):
   "打印所有参数"
   print(arg1)
   for var in vartuple:
       print(var)
   return
```

定义函数时可以给参数指定默认值, 这样在调用时就可以不传入这些参数, 没有默认值的参数是必须要传入的.

定义默认参数要牢记一点：默认参数必须指向不变对象(数, 字符串, 元组)！

参数前加了 `*` 的变量会存放所有未命名的变量.

`__name__` 是函数对象的一个属性, 可以拿到此函数的名称


#### Lambda {#lambda}

使用关键字 `lambda`, 就可以创建短小的匿名函式, 如:

```python
# 语法
lambda [arg1 [,arg2,.....argn]]:expression

sum = lambda arg1, arg2: arg1 + arg2
print(sum(10, 10) # 20
print(sum(10, 20) # 30
```

特点:

-   `lambda` 只是一个表达式, 函数体比 `def` 简单的多, 近能封装有限的逻辑进去
-   `lambda` 函数拥有自己的命名空间, 并且不能访问自有参数之外或全局命名的参数
-   `lambda` 函数虽然间短, 但不等同于 ****内联函数****


#### 装饰器 {#装饰器}

当需要增强某个函数的功能时, 但有不希望修改函数, 此时可以使用装饰器. 如添加日志功能:

```python
def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper

@log
def test():
    print("Test")
```

通过 `@` 语法就给函数 `test` 添加了日志功能

---


### 模块 {#模块}

模块就是一个 `python` 文件, 使用 `import` 导入模块, 调用模块中的方法时就必须以 `<module>.<func>` 来调用.

`from <module> import <func1>,<func2>...` 语句是从模块中导入指定的函数, `from <module> import *` 则将模块中的所有方法都导入

导入一个模块时的路径搜索顺序如下:

1.  先从当前目录查找是否有此模块
2.  如果当前目录没有, 就从 `PYTHONPATH` 定义的目录下查找
3.  如果都找不到, 就查看默认路径, `linux` 下一般是 `/usr/lib/python`

搜索路径定义在 `sys.path` 中, 可以用 `append` 函数来添加指定目录, 如项目中模块不再同一个目录就可以添加 `path` 来导入


#### 包 {#包}

`python` 中的包就是一个分层次的目录, 定义了一个由模块及子包组成的环境.

包简单来说就是一个目录, 目录中必须包含一个 `__init__.py`, 该文件可以为空, 目的使用来标识这个目录是一个包, 一个简单的例子如下:

如存在目录 `package_test` , 此目录下有 `__init__.py, foo1.py, foo2.py` 等文件

`foo1.py` 文件:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

def foo1():
    print("Foo1 test")
```

`foo2.py` 文件:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

def foo2():
    print("Foo2 test")
```

调用:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from package_test.foo1 import foo1
from package_test.foo2 import foo2

if __name__ == "__main__":
    foo1()
    foo2()
```

---


### 类 {#类}

`python` 是一门面向对象语言, 所以创建类和对象是很容易的, 先简单介绍下面向对象的一些基本特征:

-   类: 用来描述具有相同属性和方法的对象的集合, 定义了每个对象共有的属性和方法, 对象是类的实例
-   数据成员: 类中的变量, 用于处理类及对象的相关的数据
-   私有成员: 只能在类的内部方法中访问的成员
-   受保护成员: 只能由本类或子类访问的成员
-   公有成员: 全局的, 类内部, 外部和子类都能访问的成员
-   方法: 类中定义的函数
-   方法重写: 如果从父类继承的方法不满足需求, 可以对其重新实现, 这个过程就叫重写
-   操作符重载: 自定义某些操作符的功能, 如 `+` 操作符, 指明2个对象的数据如何相加
-   继承: 从一个父类派生出一个子类
-   多态: 如果多个对象都继承子一个父类, 通过传入一个父类变量来调用某个方法时, 如果此时传入的是子类的对象, 则会调用这个子类中实现的方法(方法已被重写)


#### 类的创建 {#类的创建}

`python` 中类创建的语法如下:

```python
# 创建一个类
class Human:
    # 类变量
    var1 = 0 # 公有成员
    _var2 = 0 # 受保护成员
    __var3 = 0 # 私有成员

    # 构造函数, 里面可以定义实例变量, 这些变量只有在这个函数调用后才能使用, 子类如果重写了构造函数, 则不能使用这些变量
    def __init__(self, arg1, arg2...):
        self.arg1 = arg1
        self._arg2 = arg2
        self.__arg3 = arg3

    # 类方法
    def foo(self):
        print("Var1:", var1)
        print("Arg1:", self.arg1)

"""
动态类型的语言在创建实例后, 可以给实例绑定任何的属性和方法, 但这些绑定只对当前实例有效
如果要对所以实例生效, 可以在创建实例前给动态的给类绑定
"""

# 动态的给类绑定属性和方法, 这些属性和方法所有实例都可用
Human.school = ''
# 实例化
h = Human(arg1, arg2...)
print(h.school)
# 方法调用
h.foo()
# 动态的给实例绑定属性和方法, 这些属性和方法只能该实例可用
h.parent = 'Big Joy'
# 类的销毁
del h
```

类的实例化是通过调用构造函数完成的, `__init__` 函数中定义了实例化时需要的参数.

类中以一个 `_` 开头命令的变量或方法叫做受保护成员, 以二个 `_` 开头命名的叫做私有成员, 以 `__` 开头并以 `__` 结尾的为系统定义的, 一般是内置的成员.

使用 `del` 则可销毁一个类实例.

类内置了以下属性:

-   **\_\_dict\_\_:** 类的数据属性组成的字典
-   **\_\_doc\_\_:** 类的文档
-   **\_\_name\_\_:** 类名
-   **\_\_module\_\_:** 类定义所在的模块名
-   **\_\_bases\_\_:** 类继承的所有父类的元组

---


#### 类的继承 {#类的继承}

语法如下:

```python
class SubName(Parent1, Parent2...):
    pass
```

一个子类可以继承多个父类, 使用 `isintance(obj, type)` 可以判断一个对象的类型, 使用 `issubclass(sub, parent)` 可以判断是否为另一个类的子类.


#### 方法重写 {#方法重写}

如果父类的方法不能满足子类的需求, 子类就可重写此方法, 在使用子类对象调用此方法时会调用重写后的方法.

**运算符重载** 也是方法的重写, 只不过是对一些内置方法进行重写.

下面列出一些基本的内置方法:

-   **\_\_init\_\_(self, [args]):** 构造函数, 用户实例化对象
-   **\_\_del\_\_(self):** 析构函数, 用于删除对象
-   **\_\_repr\_\_(self):** 转化为供解释器读取的形式
-   **\_\_str\_\_(self):** 用于将值转化为适于人阅读的形式
-   **\_\_cmp\_\_(self, obj):** 对象比较
-   **\_\_add\_\_(self, obj):** '+' 对象相加
-   **\_\_sub\_\_(self, obj):** '-' 对象相减
-   **\_\_eq\_\_(self, obj):** '==' 对象是否相等
-   **\_\_gt\_\_(self, obj):** '>' 对象是否小于
-   **\_\_lt\_\_(self, obj):** '<' 对象是否小于
-   **\_\_iadd\_\_(self, obj):** '+=' 对象相加

更多的内置方法请查阅手册

---

以上就介绍完了 `python` 的基础知识, 按照上面的内容就能够写出 `python` 程序了, 当然前提是你不是一个小白, 至少熟悉一门编程语言.

但 `python` 还有很多高级知识则需要你自行使用学习了, 如文件操作, 进程和线程, 网络编程, 图形编程等等. 本文的目的只是让你明白 `python` 程序应该怎么写, 怎么把你用其他语言写的程序转换成 `python` 语言的, 更多高级的特性只能靠你自己学习尝试.
